---
layout: post
title: 浅谈用Promise模式来简化Javascript异步编程
category: 技术
tags: javascript
description: 浅谈用Promise模式来简化Javascript异步编程
---

### Javascript引擎的工作机制

![忙碌的Javascript引擎](/public/upload/zuma.png)

这是一幅《祖玛》的游戏截图，想必大家都很熟悉。每天我们打开浏览器看网页时，为我们服务的Javascript（下文简称JS）引擎在浏览器里就扮演图中央这只苦逼青蛙的角色————比青蛙更苦逼的是：JS引擎每次只能处理排在队伍最前面的一个珠子。

宏观上看，这是一个简单的生产者——消费者模型：青蛙不断的消除（消费）队列中的珠子，而幕后黑手不断地向队列尾部添加（生产）珠子。

另外，图中只有一只青蛙。同样地，JS引擎也只启用一个线程（HTML5新引入的Worker除外）来执行代码——它是单线程的。

### Javascript中的异步函数

继续展开前，我们先来看看异步函数的定义。网上找来一段异步函数与同步函数的定义：

>同步函数：当一个函数是同步执行时，那么当该函数被调用时不会立即返回，直到该函数所要做的事情全都做完了才返回。
>异步函数：如果一个异步函数被调用时，该函数会立即返回尽管该函数规定的操作任务还没有完成。

用我自己的话来说：
同步函数在执行完其内部所有代码后，才会返回。直到返回前，会阻塞所在线程。同步函数的每一行代码，都是阻塞的。
而异步函数恰恰相反：可能函数中的某些代码还没被执行到，函数就返回了。异步函数可能包含部分阻塞代码，但一定包含至少一行非阻塞代码。
不难想象，一个同步函数F中,如果调用了异步函数，那在外部调用者看来，F就表现为异步。
结论：异步对它的调用环境具有传染性。

以函数为单位来考察JS的执行。回到上面的祖玛游戏，每个珠子内部包含了一次对某个函数调用（包括其内部子调用）中的“阻塞代码集”的调用。
如果你的JS代码里全是阻塞代码——OK，那青蛙要处理的珠子，只有一个。
而当青蛙处理到一行非阻塞代码，它并不处理，取而代之的是上面提到的那个不断给队列尾部追加珠子企图弄死青蛙的“幕后黑手”——它将保存这些非阻塞代码并在合适的时机将代码包装成一个新的珠子加入队列中。在Javascript的世界里，“幕后黑手”有两个分身：定时器和事件。

### 异步函数所带来的烦恼

实际上，“烦恼”这个说法是有违公平的。异步函数让像Javascript这样工作在单线程下的语言，能够更好地利用起有限的时间片。因此有一些优化规范建议将大段的同步函数，切成多个小片段，每个小片段用setTimeout(...,0)调用之。
	
引用一段工作在其他栈上的网友(win32 C)对使用异步函数作出的评价：
> 异步调用原理并不复杂，但实际使用时容易出莫名其妙的问题，特别是不同线程共享代码或共享数据时容易出问题，编程时需要时时注意是否存在这样的共享，并通过各种状态标志避免冲突。
	
虽说道理都是相通的，但异步函数带来的困扰在Javascript中看起来似乎更为严重。原因如上面所说，JS中使用异步函数的机会比其他语言要高很多————因为它是单线程的，而且一般都要与用户进行各种交互。



### 什么是Promise模式



### 用Promise模式来简化Javascript异步编程


